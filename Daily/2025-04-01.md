#dart 


## 테스트 방법
- 수동 테스트 (표준 출력을 이용해 직접 확인)
- 단위 테스트 (독립적 기능 테스트)
- 통합 테스트 (여러개 연관된 기능을 함께 테스트)

### 화이트 박스 테스트
- 내부 구조와 동작에 중점을 두고 테스트
- 내부 로직, 제어 흐름, 데이터 흐름을 이해하고 검증하는데에 사용
- 구문 검사, 경로 검사, 조건/분기 검사 등

### 블랙박스 테스트
- 내부 구조를 무시하고 기능을 테스트
- 시스템이 어떻게 동작하는지에 대한 내부 정보를 알 필요 없이 사용자 관점에서 테스트
- 테스트 케이스는 입력 값과 예상 출력 값에 기반하여 설계
- 등가 분할, 경계 값 분석, 상태 전이 테스트 등

## 테스트의 장점
- 장애에 관한 신속한 피드백
- 개발 주기에서 조기 장애 감지
- 코드를 최적화할 수 있도록 하는 더 안전한 코드 리팩터링
- 기술적 문제를 최소화하는 안정적인 개발 속도

## 테스트 더블
- 먼저 모호한 경계를 가지므로 용어에 집착 말자
- 테스트를 진행하기 어려운 경우에 테스트가 가능하도록 만들어주는 객체
	- 영화 촬영 시 위험한 역할을 대신하는 스턴트 더블에서 비롯됨

## Mock
때때로 단위 테스트는 라이브 웹 서비스 또는 데이터베이스 등 어플리케이션과 관계 없는 외부에서 데이터를 가져오는 클래스에 의존할 수 있다.

이는 다음과 같은 몇 가지 이유로 불편하다.

- 네트워크 통신으로 인해 테스트 실행 속도가 느림
- 외부 요인에 의해 잠재적으로 실패할 수 있음
- 모든 성공 및 실패 시나리오를 테스트하는 것이 어려움

따라서 기대하는 출력 결과를 미리 명세해놓고 사용하는 Mock 객체를 활용하여 외부 환경에 의존하지 않는 가짜 객체를 만들어서 활용한다.

### Mockito
- Mock 객체 작성용 Test 라이브러리

## 좋은 단위 테스트의 6가지 조건 (FRIEND)
- Fast 빠르고
- Reliable 믿을 수 있고
- Independent 독립적이고
- Ease of Maintenance 유지보수가 쉽고
- Nearly compacted code 압축적인 코드
- Dependencies should be less 의존성이 적어야 함

F.I.R.S.T
https://howtodoinjava.com/best-practices/first-principles-for-good-tests/

## Model Class
- 별도의 기능을 가지지 않는 순수한 클래스
- `hashCode`, `toString()`, `copyWith()`, `==` 재정의
- 불변성을 가져야함
- 필요 시 직렬화, 역직렬화 기능 제공

```dart
class User {
	final String name;
	final int age;

	const User(this.name, this.age);

	@override
	String toString() => 'User(name: $name, age: $age)';
}
```

## 값 객체 (Value Object, VO)
- 불변성을 가져야함 (setter가 없음)
- 내부 값 동등성 검사할 수 있어야 함 (`==`, `hashCode`)
- 자가 유효성 검사 필요 (생성자에서 검증)

## Constant Constructor
- 불변 객체의 경우 컴파일 타임 상수로 선언 가능
- 생성자의 앞에 `const` 키워드를 붙이고 인스턴스 생성 시에도 `const` 키워드 사용 해야 함
- 컴파일 타임 상수로 생성되어 내부 속성의 값이 같다면 같다고 봄

## DataSource VS Repository
- 데이터소스는 데이터 처리 역할에 집중
	- FILE을 조작하거나
	- 서버와 통신하거나
	- 메모리를 사용하거나
- 리포지토리는 비즈니스 로직에 집중
	- Map을 모델 클래스로 변환
	- 데이터베이스 서버와 통신하거나 데이터 생성, 수정, 삭제 등
	- 도메인 특화 기능 제공 
		- `findUsersOrderByNameDescending()`
		- `findActiveUsers()`
