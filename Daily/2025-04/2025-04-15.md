#flutter 

## 뷰 모델 로딩
- 생명주기 함수 중 InitState을 사용해서 로딩할 것

## dispose()
- 내 위젯을 먼저 dispose하고 super.dispose() 호출 하는 것이 권장됨

## ValueNotifier\<T>
- T는 값의 타입
- `ChangeNotifier`를 상속받음
- ChangeNotifer와 동일한 동작을 하는 반면 `notifyListeners()`를 알아서 호출함


## MediaQuery.sizeOf
- MediaQuery.height.size 대신 sizeOf를 사용

## 라우팅
- go_router 패키지 사용

```dart
class MyApp extends StatelessWidget {
	@override
	Widget build(BuildContext context) {
		return MaterialApp.router(
			routerConfig: _router
		),
	},
}
```

- path는 기본적으로 웹 URI 구성을 그대로 따름

```dart
import 'package:go_router/go_router.dart';

final _router = GoRouter(
	routes: [
		GoRoute(
			path: '/',
			builder: (context, state) => HomeScreen(),
		),
	],
);
```


- go_router 주요 메서드
	- context.go() 현재 화면을 교체 (replace)
	- context.push() 새로운 화면을 위에 쌓음 (뒤로가기 가능)

### 사용 이유
- 프로젝트가 커질수록 코드 관리 복잡해짐
- 웹 지원, 딥링크를 하려면 go_router는 거의 필수

### 기능
- 웹 주소(URL) 기반 경로 지정
- Deep Link, Nested Route, Shell Route 지원


### 다양한 데이터 전달 방법

1. extra를 사용한 데이터 전달 (비추천)
	- 위 방법은 간단하지만 앱 내에서만 동작함
	- 외부 링크나 딥 링크로는 전달할 수 없고, 앱 재시작 시 `extra`의 데이터는 손실됨
2. path 파라미터를 이용한 데이터 전달 (추천)
	- id만 전달하고 내부에서 다시 조회
	- 앱이 커질수록 유지봇가 편함
	- 웹 URL과 딥 링크에도 대응 가능
	- 일반적인 백엔드 컨트롤러와 유사
3. query 파라미터를 이용한 방법
	- queryParameters로 `Map<String, String>`만 전달 가능
	- 받는 쪽에서 파싱해서 사용


### 중첩 라우트 (Nested Route)
- 라우터 안에 또 다른 라우터 구성 가능
- 큰 화면 안에 작은 화면이 들어가는 구조 (예: BottomNavigation)

### 라우트 상수 관리
- 상수로 경로를 관리하는 것이 좋음

### ShellRoute
- 