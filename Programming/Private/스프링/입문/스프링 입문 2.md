---
title:
tags:
  - java
  - programming
  - spring
  - aop
publish: true
date: 2024-11-14
---

## H2 데이터베이스 설치

이 전 강의까지는 메모리에 회원의 정보를 저장해놓아서 서버가 재시작되면 모든 회원이 사라지는 문제가 발생했다. 이 문제를 해결하기 위해 데이터베이스를 사용한다.

H2 데이터베이스는 개발이나 테스트 용도로 가볍고 편리한 데이터베이스이고, 웹 화면도 제공한다.

H2 데이터베이스 설치 및 설정은 이 문서에서 설명 하지 않는다.

```sql
drop table if exists member CASCADE;
create table member (
id bigint generated by default as identity,
name varchar(255),
primary key (id)
);
```

설치와 설정이 모두 끝나면 위의 SQL문을 사용해서 멤버 테이블을 생성한다.

## JDBC

> [!warning]
> 이렇게 `JDBC API`로 직접 코딩하는 것은 20년 전 이야기이다. 따라서 고대 개발자들이 이렇게 고생하고 살았구나 생각하고 얼마나 힘들었는지 체험해보기 위한 과정이다. 정신건강을 위해 참고만 하고 넘어가자.

### 환경 설정

먼저 `build.gradle`에 `jdbc`와 `h2` 데이터베이스 관련 라이브러리를 추가해야 한다.

```
implementation 'org.springframework.boot:spring-boot-starter-jdbc'
runtimeOnly 'com.h2database:h2'
```

위 두 줄을 `build.gradle` 내의 `dependencies`에 추가한다. 그 후에 `resources/application.properties` 파일에 아래 내용을 추가한다. 아마 `properties` 파일이 `Node.js`에서 자주 사용했던 `.env`와 비슷한 환경변수 제공 파일인 것 같다.

```
spring.datasource.url=jdbc:h2:tcp://localhost/~/test
spring.datasource.driver-class-name=org.h2.Driver
spring.datasource.username=sa
```

마지막으로 새로운 라이브러리와 설정을 적용하려면 `gradle`을 다시 로드 해야한다.

### 순수 JDBC API로 MemberRepository 구현

앞서 `MemberRepository` 인터페이스를 작성해놓았으므로 해당 인터페이스를 구현하는 `JdbcMemberRepository` 클래스를 작성 해야한다.

강의에선 코드 작성 시간이 너무 오래걸리고, 구현 시간이 아까우므로 그냥 소스코드를 복사 붙여넣기 해서 설명한다.

```java title=""
@Override
public Member save(Member member) {
    String sql = "insert into member(name) values(?)";
    Connection conn = null;
    PreparedStatement pstmt = null;
    ResultSet rs = null;
    try {
        conn = getConnection();
        pstmt = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
        pstmt.setString(1, member.getName());
        pstmt.executeUpdate();
        rs = pstmt.getGeneratedKeys();
        if (rs.next()) {
            member.setId(rs.getLong(1));
        } else {
            throw new SQLException("id 조회 실패");
        }
        return member;
    } catch (Exception e) {
        throw new IllegalStateException(e);
    } finally {
        close(conn, pstmt, rs);
    }
}
```

단순히 저장만 하는 `save()`의 코드가 너무 장황하고, 너무나 많은 `Exception`을 던진다. 그리고 사용한 리소스들도 필수로 반환해야 한다.

다음은 `SpringConfig`을 수정한다. 현재 프로젝트는 직접 [[스프링 입문 1#직접 스프링 빈 등록|스프링 빈 등록]] 하는 방식으로 되어있다. 따라서 구현체가 변경되었기 때문에 `JdbcMemberRepository`로 변경해주어야 한다.

```java title="SpringConfig.java"
@Configuration
public class SpringConfig {

    private DataSource dataSource;

    @Autowired
    public SpringConfig(DataSource dataSource) {
        this.dataSource = dataSource;
    }

    @Bean
    public MemberRepository memberRepository() {
        return new JdbcMemberRepository(dataSource);
    }

	...

}
```

`DataSource`는 데이터베이스 커넥션을 획득할 때 사용하는 객체다. 스프링 부트는 데이터베이스 커넥션 정보를 바탕으로 `DataSource`를 생성하고 스프링 빈으로 만들어둔다. 따라서 `SpringConfig`에서 `@Autowired` 어노테이션으로 생성자 주입 받을 수 있게 된다.

![[spring-start-2.png]]

> [!note] 스프링을 사용하는 이유
> 방금과 같은 사례에서, 객체지향 설계의 장점을 보았다. 다형성을 활용해서 인터페이스를 두고 구현체만 변경하면 다른 코드들을 변경하지 않아도 된다.
>
> 스프링은 개발자의 편의를 위해 이를 스프링 컨테이너로 지원한다. 소위 말하는 의존성 주입(Dependencies Injection) 덕분에 굉장히 편리하게 사용할 수 있게 한다.
>
> 다형성을 활용하고, 스프링의 DI를 사용하면 기존 코드를 전혀 손대지 않고, 설정만으로 구현 클래스를 변경하는 것이다.
>
> 마치 레고 블록을 조립하는 것과 비슷하다.

### 스프링 통합 테스트 작성

현재 작성된 테스트는 개별적인 유닛 테스트로 작성되어 있다. 스프링과 전혀 관련이 없다. 순수한 자바 코드와 메모리만을 이용하는 `MemoryMemberRepository`를 기반으로 되어있다.

스프링 컨테이너와 H2 데이터베이스까지 연결한 통합 테스트를 작성한다.

```java
@SpringBootTest
@Transactional
class MemberServiceIntegrationTest {
    @Autowired MemberService memberService;
    @Autowired MemberRepository memberRepository;

    @Test
    void 회원가입() {
        // Given
        Member member = new Member();
        member.setName("spring");

        // When
        Long saveId = memberService.join(member);

        // Then
        Member one = memberService.findOne(member.getId()).get();
        assertThat(member.getName()).isEqualTo(one.getName());
    }

    ...
}
```

- `@SpringBootTest`: 이 어노테이션을 적용하면 스프링 컨테이너와 테스트를 함께 실행한다.
- `@Transactional`: 테스트 케이스에 이 어노테이션을 적용하면, 테스트 시작 전에 트랜잭션을 시작하고 테스트 완료 후에 항상 롤백한다. 테스트 메서드 하나 하나마다 롤백 되는 것이다. 이렇게하면 데이터베이스에 데이터가 남지 않으므로 다음 테스트에 영향을 주지 않으므로 반복 실행이 가능해진다.

데이터베이스는 수정하는 작업(추가, 수정, 삭제)을 할 때 수정되기 전 `COMMIT`이라는 단계가 존재한다. 수정하는 작업을 완료하기 전에 `COMMIT`을 하지 않으면 데이터베이스에 적용이 되지 않는다.

### 스프링 JdbcTemplate

스프링 `JdbcTemplate`과 `MyBatis`같은 라이브러리는 `JDBC API`에서 본 반복 코드를 대부분 제거해준다. 하지만 `SQL`은 직접 작성해야 한다.

```java
public class JdbcTemplateMemberRepository implements MemberRepository {
    private final JdbcTemplate jdbcTemplate;

    public JdbcTemplateMemberRepository(DataSource dataSource) {
        this.jdbcTemplate = new JdbcTemplate(dataSource);
    }

    @Override
    public Optional<Member> findById(Long id) {
        List<Member> result = jdbcTemplate.query("select * from member where id = ?", memberRowMapper());

        return result.stream().findAny();
    }

    private RowMapper<Member> memberRowMapper() {
        return (rs, rowNum) -> {
            Member member = new Member();
            member.setId(rs.getLong("id"));
            member.setName(rs.getString("name"));

            return member;
        };
    }

    ...
}
```

- 생성자가 하나일 경우, 의존성 주입 어노테이션인 `@Autowired`를 생략할 수 있다.

이 전의 `JdbcMemberRepository`에 비해서 코드가 엄청나게 줄어든 것을 확인했다. `JdbcTemplate`는 디자인 패턴 중 템플릿 메서드 패턴을 이용했다고 한다.

`memberRowMapper()`는 결과인 `row` 값들을 멤버 객체로 변환하고 맵핑해주는 메서드다. 줄이고 줄였으나 그래도 `ORM`이 그립다.

## JPA (Java Persistence API)

앞서 순수한 `JDBC`의 코드, `JDBC Template`를 사용한 코드 두 가지를 모두 살펴보았다. `JPA`는 두 가지가 가진 반복 코드나 `SQL` 작성등의 문제를 모두 해결하여 `SQL`과 데이터 중심의 설계에서 객체 중심의 설계로 패러다임을 전환한다.

이 `JPA`를 사용하면 개발 생산성을 크게 높일 수 있다.

> [!tip] Java Persistence API
>
> - JPA는 자바 ORM 기술에 대한 표준 명세로, JAVA에서 제공하는 API이다. 스프링에서 제공하는것이 아니다.
> - 자바 어플리케이션에서 관계형 데이터베이스를 사용하는 방식을 정의한 인터페이스다.
> - 여기서 중요한건 JPA는 말 그대로 인터페이스이다.
> - ORM을 사용하기 위한 인터페이스를 모아둔 것이며, JPA를 사용하기 위해서는 JPA를 구현한 Hibernate 같은 ORM 프레임워크를 사용해야한다.

### 환경 설정

JPA를 사용하기 위해서는 `build.gradle`의 `dependencies`에 라이브러리를 추가해야 한다.

```
implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
```

그리고 이 전에 추가했던 `implementation 'org.springframework.boot:spring-boot-starter-jdbc'`는 지운다. 추가한 `JPA` 라이브러리에 포함되어 있는 라이브러리이기 때문이다.

그 후에 `application.properties`에 `JPA` 관련 설정을 해주어야 한다.

```
spring.jpa.show-sql=true
spring.jpa.hibernate.ddl-auto=none
```

- `spring.jpa.show-sql=true`: `JPA`가 생성하는 SQL을 출력한다.
- `spring.jpa.hibernate.ddl-auto=none`: `JPA`는 테이블을 자동으로 생성하는 기능을 제공하는데, `none` 을 사용하면 해당 기능을 끈다.
  - `create`를 사용하면 엔티티 정보를 바탕으로 테이블도 직접 생성해준다.

### 엔티티 맵핑

엔티티 맵핑은 `TypeORM` 처럼 클래스에 어노테이션을 적용하며 맵핑한다.

```java
@Entity
public class Member {
    @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;

    public Long getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public void setName(String name) {
        this.name = name;
    }
}
```

### JPA 회원 레포지토리 생성

```java
public class JpaMemberRepository implements MemberRepository {
    private final EntityManager em;

    public JpaMemberRepository(EntityManager em) {
        this.em = em;
    }

    @Override
    public Member save(Member member) {
        em.persist(member);

        return member;
    }

    @Override
    public Optional<Member> findById(Long id) {
        Member member = em.find(Member.class, id);

        return Optional.ofNullable(member);
    }

    @Override
    public Optional<Member> findByName(String name) {
        List<Member> result = em.createQuery("select m from Member m where m.name = :name", Member.class)
                .setParameter("name", name)
                .getResultList();

        return result.stream().findAny();
    }

    @Override
    public List<Member> findAll() {
        return em.createQuery("select m from Member m", Member.class).getResultList();
    }
}
```

`JPA`를 사용한 덕분에 확실하게 코드가 줄어들었고 한 눈에 파악하기 쉬워졌다.

> [!warning] JPA와 Transaction
> JPA를 사용해서 데이터를 저장하거나 수정, 삭제할 땐 항상 트랜잭션이 있어야한다. 그래서 위 `JpaMemberRepository`를 사용하는 서비스 계층에 `@Transactional` 어노테이션을 추가해야 한다.
>
> 쉽게 말해, JPA를 통한 모든 데이터 변경은 트랜잭션 안에서 실행해야 한다.
>
> 스프링은 해당 클래스의 메서드를 실행할 때 트랜잭션을 시작하고, 메서드가 정상 종료되면 트랜잭션을 커밋한다. 만약 런타임에 예외가 발생하면 롤백한다.

## 스프링 데이터 JPA

스프링 부트와 JPA만 사용해도 개발 생산성이 정말 많이 증가한다. 여기에 스프링 데이터 JPA를 사용하면 기존의 한계를 넘어 마치 마법처럼, 리포지토리에 구현 클래스 없이 인터페이스만으로 개발을 완료할 수 있다.

스프링 부트와 JPA라는 기반 위에, 스프링 데이터 JPA라는 환상적인 프레임워크를 더하면 개발이 더 즐거워진다.

따라서 개발자는 핵심 비즈니스 로직을 개발하는데 집중할 수 있게 된다. 실무에서 관계형 데이터베이스를 사용한다면 스프링 데이터 JPA는 선택이 아니라 필수이다.

> [!warning] 주의
> 스프링 데이터 JPA는 JPA를 편리하게 사용하도록 도와주는 기술이다. 따라서 JPA를 먼저 학습한 후에 스프링 데이터 JPA를 학습해야 한다.

환경 설정은 앞서 설정했던 JPA 설정을 그대로 사용한다.

### 스프링 데이터 JPA 회원 리포지토리 구현

```java
public interface SpringDataJpaMemberRepository extends JpaRepository<Member, Long>, MemberRepository {
    @Override
    Optional<Member> findByName(String name);
}
```

스프링 데이터 JPA는 과거 `NestJS`를 이용한 프로젝트를 할 때 사용해보았던 우아한 형제들의 [nestjs-library-crud](https://github.com/woowabros/nestjs-library-crud) 패키지와 비슷한 기능을 제공한다.

- 인터페이스를 통한 기본적인 CRUD 생성
- `findByName()` , `findByEmail()` 처럼 메서드 이름 만으로 조회 기능 제공
- 페이징 기능 자동 제공

위 코드는 단순히 인터페이스간의 상속만을 통해서 CRUD 기능을 생성한 것이다.

- **JpaRepository<Member, Long>**: 이 인터페이스를 상속하면, 스프링 데이터 JPA가 자동으로 구현체를 만들고 스프링 빈에 등록한다.
- **MemberRepository**: 다형성을 활용하기 위해서 인터페이스를 상속한다.
- **findByName(String name)**: JpaRepository 인터페이스가 공통으로 만들어 낼 수 없는 메서드이다. 메서드 이름을 `findByXXX()`으로 오버라이딩 하면 스프링 데이터 JPA가 자동으로 해당 메서드의 `JPQL`을 작성해서 만든다.

```java title="SpringConfig.java"
@Configuration
public class SpringConfig {
    private final MemberRepository memberRepository;

    @Autowired
    public SpringConfig(MemberRepository memberRepository) {
        this.memberRepository = memberRepository;
    }

    @Bean
    public MemberService memberService() {
        return new MemberService(memberRepository);
    }
}
```

앞서 `JpaRepository<T, ID>`를 상속한 인터페이스는 스프링 데이터 JPA가 자동으로 구현체를 만들고 스프링 컨테이너에 등록한다고 했다.

등록된 컨테이너에서 `memberRepository`를 주입받기 위해 필드와 생성자를 만들어 준 뒤에 서비스에 주입한다.

> [!tip] 참고
> 실무에서는 JPA와 스프링 데이터 JPA를 기본으로 사용하고, 복잡한 동적 쿼리는 `Querydsl`이라는 라이브러리를 사용하면 된다. `Querydsl`을 사용하면 쿼리도 자바 코드로 안전하게 작성할 수 있고, 동적 쿼리도 편리하게 작성할 수 있다.
>
> 이 조합으로 해결하기 어려운 쿼리는 JPA가 제공하는 네이티브 쿼리를 사용하거나 앞서 학습한 스프링 `JDBC Template`를 사용하면 된다.

## AOP (Aspect Oriented Programming)

AOP는 관점 지향 프로그래밍이라고도 불린다.

### AOP가 필요한 상황

- 모든 메소드의 호출 시간을 측정하고 싶다면?
- 공통 관심 사항(cross-cutting concern) vs 핵심 관심 사항(core concern)
- 회원 가입 시간, 회원 조회 시간을 측정하고 싶다면?

예를 들어 모든 메소드의 호출 시간을 측정하기 위해서는 단순하게 구현한다는 가정 하에 메서드가 1000개라면 1000개에 모두 시간 측정 코드를 작성해야 한다.

**문제**

- 회원가입, 회원 조회에 시간을 측정하는 기능은 **핵심 관심 사항**이 아니다.
- 시간을 측정하는 로직은 **공통 관심 사항**이다.
- 시간을 측정하는 로직과 핵심 비즈니스의 로직이 섞이면 유지보수 하기 힘들다.

회원가입에서 핵심 관심 사항은 회원가입이 오류 없이 잘 작동하는 것이지 시간을 측정하는 것이 아니다.

이런 경우 AOP를 적용해서, 공통 관심 사항과 핵심 관심 사항을 분리하고 문제들을 해결할 수 있다.

### AOP 적용

![[spring-start-aop-1.png]]
위 그림에서 알 수 있듯이 핵심은 **공통 관심 사항과 핵심 관심 사항을 분리하는 것**이다.

스프링에서는 이 AOP를 잘 사용할 수 있게 제공한다.

```java
@Aspect
@Component
public class TimeTraceAop {

    @Around("execution(* hello.hello_spring..*(..))")
    public Object execute(ProceedingJoinPoint joinPoint) throws Throwable {
        long start = System.currentTimeMillis();
        System.out.println("Start: " + joinPoint.toString());
        try {
             return joinPoint.proceed();
        } finally {
            long end = System.currentTimeMillis();
            long timeMs = end - start;
            System.out.println("END: " + joinPoint.toString() + " " + timeMs + "ms");
        }
    }
}
```

- `@Aspect`: 이 어노테이션을 적용해야 AOP로 사용할 수 있다.
- `@Component`: 스프링 컨테이너에 자동으로 등록하기 위해 적용했다.
- `@Around`: 명시적으로 적용 범위를 작성해야 한다. 이를 위한 문법은 따로 존재한다고 한다.

위 코드를 보면 마치 콜백 함수를 사용하는 것 처럼 코드를 작성한다. 어떻게 동작하는지 알아본다.

![[spring-start-aop-2.png]]

- `@Around()`에 적용되어 있는 범위를 통해서, 사용할 서비스의 범위가 지정된다.
- 프록시라고 하는 가짜 `memberService`를 만들어 낸다.
- `memberController`가 `memberService`의 메서드를 호출하면, `TimeTraceAop`의 `execute()`가 실행된다.
- `execute()`에서 `joinPoint.proceed()`가 반환되면 그때 실제 `memberService`의 함수가 실행되고 결과가 반환 되는 것이다.

![[spring-start-aop-3.png]]

---

References: 김영한의 스프링 입문

Links to this page:
