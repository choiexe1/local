---
tags:
  - java
  - programming
date: 2024-08-21
publish: true
---

## 상속과 메소드 오버라이딩

부모 타입의 기능을 자식에서는 다르게 재정의 하고 싶을 수 있다.

예를 들어 전기차의 경우 보통 휘발유 차보다 빠르기 때문에 전기차가 move() 를 호출하는 경우에는 "전기차를 빠르게 이동합니다." 라고 출력을 변경하고 싶다.

```java
package extends1.overriding;

public class ElectricCar extends Car {
    @Override
    public void move() {
        System.out.println("전기차를 빠르게 이동합니다.");
    }

    public void charge() {
        System.out.println("전기를 충전합니다.");
    }
}
```

> 어노테이션(Annotaion)
> 코드 중 `@`이 붙은 라인의 코드를 어노테이션이라고 한다. 어노테이션은 주석과 비슷하나 프로그램이 읽을 수 있는 특별한 주석이다.
>
> 위 코드에서 `@Override` 어노테이션은 `move()`가 상위 클래스의 메서드를 오버라이드 하는 것임을 나타낸다. 이 어노테이션은 생략이 가능하지만, 슈퍼(부모)에 해당 메서드가 없으면 컴파일 오류가 발생한다. 코드의 명확성을 위해 오버라이딩 시 붙여주는 것이 좋다.

[[상속#핵심 정리]]를 따르면, 기본적으로 호출자의 타입을 통하여 기능을 먼저 찾고 호출하기 때문에 작동한다고 볼 수 있겠다.

메소드 오버라이딩이란 상속 관계에서 물려받은 기능을 덮어쓰는 것이다.

### 메서드 오버라이딩 조건

- 메서드 이름이 같아야 한다.
- 파라미터 타입, 순서, 갯수가 같아야 한다.
- 반환 타입이 같아야 한다. 단, 반환 타입이 하위 클래스 타입일 수 있다.
- 접근 제어자는 상위 클래스의 메서드보다 더 제한적일 수 없다.
- 오버라이딩 메서드는 상위 클래스의 메서드보다 더 많은 체크 예외를 throw로 선언할 수 없다. 하지만 더 적거나 같은 수의 예외, 또는 하위 타입의 예외는 선언할 수 있다.
- static, final, private 키워드가 붙은 메서드는 당연하게도 오버라이딩 될 수 없다.
- 생성자는 오버라이딩 할 수 없다.

### 상속 관계에서의 접근 제어와 메모리 구조

본인 타입에 없으면 부모 타입에서 기능을 찾는데, 이 때 접근 제어자가 영향을 주는 이유는 객체 내부에서는 자식과 부모가 구분 되어 있기 때문이다. 결국 자식 타입에서 부모 타입의 기능을 호출할 때 부모 입장에서는 외부에서 호출한 것과 같다.

### super 키워드 - 부모 참조

상속 관계에서, 부모와 자식의 필드명이 같거나 메서드가 오버라이딩 되어 있으면 자식에서 부모의 필드나 메서드를 호출 할 수 없다.

이는 자식과 동일한 이름의 필드나 메서드가 있다면 자식에서 먼저 찾아서 사용하는 작동 방식 때문이다.

이 때 자식 클래스의 내부에서 super 키워드를 사용하면 부모를 참조할 수 있다. super 키워드를 사용하여 객체 스스로의 상위 타입을 찾아 필드나 메서드를 참조한다.

### super 키워드 - 생성자

상속 관계에서 자식 클래스의 생성자에 항상 `super()`를 통하여 상위 클래스의 생성자를 호출해야 한다. 이유는 여러가지인데, 생성자를 호출하지 않으면 객체는 생성되지 않기 때문이고 한 객체의 내부에 부모와 자식이 모두 생성된다고 했던 것을 기억해보면 된다.

만약 상위 클래스에 생성자를 정의하지 않았다면 하위 클래스에서 사용할 때 `super()`를 생략할 수 있다. 이는 클래스에 생성자를 정의하지 않으면 기본 생성자가 제공되는 것을 사용하는 것이다.

다만 상위 클래스에 생성자가 정의되어 있다면 반드시 상위 클래스의 생성자를 호출 해야한다.
예외로 생성자 첫줄에 `this(..)` 를 통하여 자기 자신의 생성자를 호출 할 수는 있다.

하지만 super는 자식의 생성자 안에서 언젠가는 반드시 호출해야 한다.

상속 관계에서 생성자의 실행 순서는 최상위 클래스로부터 최하위 클래스로 이어진다. 따라서 초기화는 최상위 부모부터 이루어진다. 이유는 자식 클래스는 부모 클래스의 속성이나 메서드를 상속받아 사용하는 입장이기 때문이다.

---

References: [[메서드 오버라이딩]] [[상속#핵심 정리]]

Links: [[상속]], [[프록시 패턴과 데코레이터 패턴]]
