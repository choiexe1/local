---
title:
tags:
  - java
  - programming
  - data-structure
  - algorithm
  - set
  - collection-framework
publish: true
date: 2024-11-04
---

## 자바가 제공하는 Set 1 - HashSet, LinkedHashSet

![[자바-set.png]]

위는 자바에서 제공하는 컬렉션 프레임워크 `Set`의 구조도이다.

**Set 인터페이스**

자바의 `Set` 인터페이스는 `java.util` 패키지의 컬렉션 프레임워크에 속하는 인터페이스 중 하나이다.

`Set` 인터페이스는 중복을 허용하지 않는 유일한 요소의 집합을 나타낸다. 즉, 어떤 요소도 같은 `Set` 내에 두 번 이상 나타날 수 없다. `Set`은 수학적 집합 개념을 구현한 것으로, 순서를 보장하지 않으며, 특정 요소가 집합에 있는지 여부를 확인하는 데 최적화 되어 있다.

`Set` 인터페이스는 `HashSet`, `LinkedHashSet`, `TreeSet`등의 여러 구현 클래스를 가지고 있으며, 각 클래스는 `Set` 인터페이스를 구현하며 각각의 특성을 가지고 있다.

지금부터 `Set` 인터페이스의 주요 구현체를 하나씩 알아본다.

1. `HashSet`
2. `LinkedHashSet`
3. `TreeSet`

### HashSet

- **구현**: 해시 자료구조를 사용해서 요소를 저장한다.
- **순서**: 요소들은 특정한 순서 없이 저장된다. 즉, 요소를 추가한 순서를 보장하지 않는다.
- **시간 복잡도**: `HashSet`의 주요 연산(추가, 삭제, 검색)은 평균적으로 `O(1)`의 시간 복잡도를 가진다.
- **용도**: 데이터의 유일성만 중요하고, 순서가 중요하지 않은 경우에 적합하다.

앞서 우리가 구현한 [[해시 알고리즘 3#직접 구현하는 Set 4 (제네릭과 인터페이스 도입)|MyHashSet]]이 바로 `HashSet`이다.

### LinkedHashSet

- 구현: `LinkedHashSet`은 `HashSet`에 연결 리스트를 추가해서 요소들의 순서를 유지한다.
- 순서: 요소들은 추가된 순서대로 유지된다. 즉, 순서대로 조회 시 요소들이 추가된 순서대로 반환된다.
- 시간 복잡도: `HashSet`과 마찬가지로 주요 연산에 대해 평균 `O(1)`의 시간 복잡도를 가진다.
- 용도: 데이터의 유일성과 함께 삽입 순서를 유지해야 할 때 적합하다.
- 참고: 연결 링크를 유지해야 하기 때문에 `HashSet`보다는 조금 더 무겁다.

![[linked-hash-set.png]]

- `LinkedHashSet`은 `HashSet`에 연결 링크만 추가한 것이다. `HashSet`에 `LinkedList`를 합친 것으로 이해하면 된다.
- 데이터를 삽입할 때 노드로써 추가하고, 순서를 `LinkedList`처럼 삽입 순서대로 연결하는 것이다.
- 예시로 첫 번째 데이터인 `1`을 삽입할 때 `Node`를 생성하고 해당 `Node`에 값을 넣는다. 그 후에 들어오는 데이터는 또 다시 노드를 생성하고, 해당 노드에 대한 참조값을 `1`번 노드에 연결한다.
  - `head(first)`부터 순서대로 링크를 따라가면 입력 순서대로 데이터를 순회할 수 있게 된다.
  - 양방향으로 연결된다. (그림에서는 이해를 돕기 위해 화살표는 다음 순서로만 보여주었다. 실제로는 양방향이다.)
- 이미지에서는 `1`, `2`, `5`, `8`, `14`, `99` 순서대로 입력된다. 해당 순서대로 연결 되어 있는 것을 확인할 수 있다.

## 자바가 제공하는 Set 2 - TreeSet

`TreeSet`을 이해하려면 먼저 트리 구조를 알아야 한다.

![[tree-structure.png]]

- 트리(Tree)는 부모 노드와 자식 노드로 구성된다.
- 가장 높은 조상을 루트(root, 뿌리)라 한다.
- 자식이 2개까지 올 수 있는 트리를 **이진 트리**라 한다.
- 여기에 노드의 왼쪽 자손은 더 작은 값을 가지고, 오른쪽 자손을 더 큰 값을 가지는 것을 **이진 탐색 트리**라 한다.
- 자바가 제공하는 `TreeSet`은 이진 탐색 트리를 개선한 레드-블랙 트리를 사용한다. 기본 개념은 비슷하므로 이진 탐색 트리의 원리를 알아보자.

##### TreeSet

- **구현**: `TreeSet`은 이진 탐색 트리를 개선한 레드-블랙 트리를 내부에서 사용한다.
- **순서**: 요소들은 정렬된 순서로 저장된다. 순서의 기준은 비교자(`Comparator`)로 변경할 수 있다. 비교자는 뒤에서 다룬다.
- **시간 복잡도**: 주요 연산들은 O(log n)의 시간 복잡도를 가진다. 따라서 `HashSet`보다는 느리다.
- **용도**: 데이터를 정렬된 순서로 유지하면서 집합의 특성을 유지해야 할 때 사용한다. 예를 들어, 범위 검색이나 정렬된 데이터가 필요한 경우에 유용하다. 참고로 입력된 순서가 아니라 데이터 값을 기준으로 순서를 따진다.
  예를 들어 `3`, `1`, `2`를 순서대로 입력해도 `1`, `2`, `3` 순서로 출력된다.

**트리 구조의 구현**

![[tree-structure-implements.png]]

```java
class Node {
	Object item;
	Node left;
	Node right;
}
```

- 트리 구조는 왼쪽, 오른쪽 노드를 알고 있으면 된다.
- 앞서 다룬 [[노드와 연결, 연결 리스트|연결 리스트]]의 구현을 떠올려보면 쉽게 이해가 될 것이다.

#### 이진 탐색 트리 - 입력 예시

이진 탐색 트리의 핵심은 데이터를 입력하는 시점에 정렬해서 보관한다는 점이다.
그리고 작은 값은 왼쪽에, 큰 값은 오른쪽에 저장한다.
데이터를 `10`, `5`, `15`, `1`, `6`, `11`, `16` 순서대로 입력한다고 가정해보자.

처음에 `10`을 입력하고, 다음으로 `5`, `15`를 입력한다.

![[binary-search-tree-example-01.png]]

- `5`는 `10`보다 작으므로 왼쪽에 저장된다.
- `15`는 `10`보다 크므로 오른쪽에 저장된다.

![[binary-search-tree-example-02.png]]

- `1`은 `10`보다 작다, 따라서 왼쪽으로 찾아간다. `1`은 `5`보다 작다. 왼쪽에 저장된다.
- `6`은 `10`보다 작다, 따라서 왼쪽으로 찾아간다. `6`은 `5`보다 크다. 오른쪽에 저장된다.

#### 이진 탐색 트리 - 검색 예시

![[binary-search-tree-example-03.png]]

위 이미지에는 총 15개의 데이터가 들어있다. 여기선 숫자 `35`를 검색한다고 가정한다.

1. 루트인 `20`과 `35`를 비교한다. `35`가 더 크므로 오른쪽으로 찾아간다.
2. `40`과 `35`를 비교한다. `35`가 더 작으므로 왼쪽으로 찾아간다.
3. `30`과 `35`를 비교한다. `35`가 더 크므로 오른쪽으로 찾아간다.
4. 노드에 있는 값을 비교한다. `35`와 같으므로 `35`를 찾는다.

데이터가 총 15개인데, 4번의 계산만으로 필요한 결과를 찾았다. 이것은 `O(n)`인 리스트의 검색보다는 빠르고, `O(1)`인 해시의 검색보다는 느리다.

- 리스트의 경우 `O(n)`이므로 15번의 연산이 필요하다.
- 해시 검색은 `O(1)`이므로 1번의 연산이 필요하다.

이진 탐색 트리 계산의 핵심은 한번에 절반을 날린다는 점이다. 계산을 단순화 하기 위해 16개의 데이터가 있다고 가정하자.

- 16개의 데이터가 있다. 루트에서 처음 비교를 통해 절반의 데이터를 찾지 않아도 된다. 따라서 16 / 2 = 8이 된다.
- 8개의 데이터가 있다. 비교를 통해 절반만 남는다. 8 / 2 = 4가 된다.
- 4개의 데이터가 있다. 비교를 통해 절반만 남는다. 4 / 2 = 2가 된다.
- 2개의 데이터가 있다. 비교를 통해 절반만 남는다. 2 / 2 = 1이 된다.
- 1이 남았으므로 이 값이 맞는지 확인하면 된다.

##### 이진 탐색 트리의 빅 오 - O(log n)

![[binary-search-trees-bigO.png]]

16개 데이터의 경우 단 4번의 비교만으로 최종 노드에 도달할 수 있다.

[[수학 로그|로그]]에 관한 내용은 링크된 문서에 정리되어 있다.

- 16개의 데이터는 2로 1번 나누면 된다.
  - $2^4$이다.
  - 로그 표현은 $log_2(16) = 4$
- 32개의 데이터는 2로 5번 나누면 된다.
  - $2^5$이다.
  - 로그 표현은 $log_2(32) = 5$
- 64개의 데이터는 2로 6번 나누면 된다.
  - $2^6$이다.
  - 로그 표현은 $log_2(64) = 6$
- 1024개의 데이터는 2로 10번 나누면 된다.
  - $2^{10}$이다.
  - 로그 표현은 $log_2(1024) = 10$

1024개의 데이터는 단 10번의 계산으로 원하는 결과를 찾을 수 있다.

데이터의 크기가 늘어나도 늘어난 만큼 한 번의 계산에 절반을 연산에서 제외하기 때문에, `O(n)`과 비교해서 데이터의 크기가 클 수록 효과적이다.

##### 이진 탐색 트리와 성능

이진 탐색 트리의 검색, 삽입, 삭제의 평균 성능은 `O(log n)`이다. 하지만 트리의 균형이 맞지 않으면 최악의 경우 `O(n)`의 성능이 나온다.

아래 예시는 만약 데이터를 1, 5, 6, 10, 15 순서로 입력했다고 가정한다.

![[binary-search-tree-worst-case.png]]

- 이렇게 오른쪽으로 치우치게 되면, 결과적으로 15를 검색 했을 때 데이터의 수인 5만큼 검색해야 한다.
- 따라서 이런 최악의 경우 `O(n)`의 성능이 나온다. 이런 경우 일반적인 `LinkedList`와 똑같아진다.

##### 이진 탐색 트리 개선

이런 문제를 해결하기 위한 다양한 해결 방안이 있는데, 트리의 균형이 너무 깨진 경우 동적으로 균형을 다시 맞추는 것이다.

![[binary-search-tree-improve.png]]

- 앞서 중간에 있는 6을 기준으로 다시 정렬한다.
- `AVL 트리`, `레드-블랙 트리`같은 균형을 맞추는 다양한 알고리즘이 존재한다.
- 자바의 `TreeSet`은 `레드-블랙 트리`를 사용해서 균형을 지속해서 유지한다. 따라서 최악의 경우에도 `O(log n)`의 성능을 제공한다.

##### 이진 탐색 트리 - 순회

- 이진 탐색 트리의 핵심은 **입력 순서가 아니라, 데이터의 값을 기준으로 정렬해서 보관한다는 점**이다.
- 따라서 정렬된 순서로 데이터를 차례로 조회할 수 있다. (순회할 수 있다.)
- 데이터를 차례로 순회하려면 **중위 순회**라는 방법을 사용하면 된다. 왼쪽 서브트리를 방문한 다음, 현재 노드를 처리하고, 마지막으로 오른쪽 서브트리를 방문한다. 이 방식은 이진 탐색 트리의 특성상, 노드를 오름차순(숫자가 점점 커지는 것)으로 방문한다.

중위 순회란 이진 탐색 트리의 특성상 왼쪽에는 작은 값, 오른쪽에는 큰 값이 존재한다. 이 특성을 이용한 방법이다.

![[중위순회.png]]

쉽게 이야기해서, 자신의 왼쪽 노드를 모두 처리하고 자신의 노드를 처리하고 자신의 오른쪽 모든 노드를 처리하는 방식이다.

- 루트인 10을 기준으로 왼쪽 서브트리를 방문한다.
  - 5의 기준에서 왼쪽 서브트리를 방문한다.
    - 1을 출력한다.
  - 5 자신을 출력하고, 오른쪽 서브트리를 방문한다.
    - 6을 출력한다.
- 10 자신을 출력하고, 오른쪽 서브트리를 방문한다.
  - 15의 기준에서 왼쪽 서브트리를 방문한다.
    - 11을 출력한다.
  - 15 자신을 출력하고, 오른쪽 서브트리를 방문한다.
    - 16을 출력한다.

순서대로 1, 5, 6, 10, 11, 15, 16이 출력된다. 여기서는 `TreeSet`을 알고 사용하기 위한 정도의 기본적인 트리 이론을 다루었다.

## 자바가 제공하는 Set 3 - 예제

```java
import java.util.*;

public class JavaSetMain {
    public static void main(String[] args) {
        Set<String> hashSet = new HashSet<>();
        LinkedHashSet<Object> linkedHashSet = new LinkedHashSet<>();
        TreeSet<Object> treeSet = new TreeSet<>();

        run(new HashSet<>());
        run(new LinkedHashSet<>());
        run(new TreeSet<>());
    }

    private static void run(Set<String> set) {
        System.out.println("SET = " + set.getClass().getSimpleName());
        set.add("C");
        set.add("B");
        set.add("A");
        set.add("1");
        set.add("2");

        Iterator<String> iterator = set.iterator();
        while (iterator.hasNext()) {
            System.out.print(iterator.next() + " ");
        }
        System.out.println();
    }
}
```

- `HashSet`, `LinkedHashSet`, `TreeSet` 모두 `Set` 인터페이스를 구현하기 때문에 다형성을 이용해 구현체를 변경하면서 실행할 수 있다.
- `iterator()`를 호출하면 컬렉션을 반복해서 출력할 수 있다.
  - `iterator.hasNext()`: 다음 데이터가 있는지 확인한다.
  - `iterator.next()`: 다음 데이터를 반환한다.

**실행 결과**

```
SET = HashSet
A 1 B 2 C
SET = LinkedHashSet
C B A 1 2
SET = TreeSet
1 2 A B C
```

- `HashSet`: 입력한 순서를 보장하지 않는다.
- `LinkedHashSet`: 입력한 순서를 보장한다.
- `TreeSet`: 데이터 값을 기준으로 정렬한다.

> [!tip] 참고
> `TreeSet`을 사용할 때 데이터를 정렬하려면 어떠한 기준이 필요하다. 크거나 작다는 기준말이다. `1`, `2`, `3`이나 `"A"`, `"B"`, `"C"` 같은 기본 데이터는 크다 작다라는 기준이 명확하기 때문에 정렬할 수 있다.
>
> 하지만 우리가 직접 만든 `Member`와 같은 객체는 크다 작다는 기준을 어떻게 알 수 있을까? 이런 기준을 제공하려면 `Comparable`, `Comparator` 인터페이스를 구현해야 한다. 이 부분은 뒤에서 설명한다.

## 자바가 제공하는 Set 4 - 최적화

자바가 제공하는 `HashSet`은 우리가 직접 구현한 내용과 거의 같지만, 다음과 같은 최적화를 추가로 진행한다.

- 해시 기반 자료 구조를 사용하는 경우 통계적으로 입력한 데이터의 수가 배열의 크기를 75% 이상 넘어가면 해시 인덱스가 자주 충돌한다. 성능이 떨어지기 시작하는 것이다.
  - 해시 충돌로 같은 해시 인덱스에 들어간 데이터를 검색하려면 모두 탐색해야 한다. 따라서 성능이 `O(n)`으로 좋지 않다.
- 하지만 데이터가 동적으로 계속 추가되기 때문에 적절한 배열의 크기를 정하는 것은 어렵다.
- 자바의 `HashSet`은 데이터의 양이 배열 크기의 75%를 넘어가면 배열의 크기를 2배 늘리고, 늘어난 크기를 기준으로 모든 요소에 해시 인덱스를 다시 적용한다.
  - 해시 인덱스를 다시 적용하는 시간이 걸리지만, 결과적으로 해시 충돌이 줄어든다.
- 자바 `HashSet`의 기본 크기는 16이다.

![[rehashing.png]]

- 데이터의 양이 배열 크기의 75% 이상이면 배열의 크기를 2배 증가시키고, 모든 데이터의 해시 인덱스를 커진 배열에 맞춰 다시 계산한다. 이 과정을 **재해싱(rehashing)**이라 한다.
- 인덱스 충돌 가능성이 줄어든다.
- 여기서 데이터가 다시 75% 이상 증가하면 다시 2배 증가와 재해싱을 반복한다.

> [!note] 정리
> 실무에서는 `Set`이 필요한 경우 `HashSet`을 가장 많이 사용한다. 그리고 입력 순서 유지, 값 정렬의 필요에 따라서 `LinkedHashSet`, `TreeSet`을 선택하면 된다.

---

References: 김영한의 실전 자바 - 중급 2편

Links to this page: [[해시 알고리즘 3]], [[노드와 연결, 연결 리스트]], [[수학 로그]], [[정렬 (Comparable, Comparator)]]
