---
title:
tags:
  - java
  - programming
  - review
date: 2024-09-12
publish: true
---

## 클래스와 데이터

- 클래스는 기본 데이터 유형을 통해 정의할 수 있는 사용자 정의 데이터 유형이다.
- 객체를 생성하면 자바는 메모리 어딘가에 이 객체에 접근할 수 있는 참조값(메모리 주소)를 반환한다.
- 즉, `Class a = new Class();` 코드에서, `a` 변수가 객체에 접근할 수 있는 메모리 주소를 가지게 된다.
- 클래스는 멤버 변수와 메서드(클래스에 속한 함수)를 가진다.
- 클래스는 실제로 존재하는 실체가 아니라, 실체를 만드는 설계도이다.
- 객체는 클래스에서 정의한 속성과 기능을 가진 실체이다. 객체는 서로 독립적인 상태를 가진다. 예를 들어 `Class a = new Class();`, `Class b = new Class();` 코드를 실행하면 `a` 변수와 `b` 변수는 같은 설계도면을 통해 만들어진 객체이지만, 각각 독립적인 상태(속성 값)를 가진다.
- 인스턴스란 특정 클래스로부터 생성된 객체를 의미한다. 그래서 객체와 인스턴스라는 용어는 자주 혼용된다. 인스턴스는 주로 객체가 어떤 클래스에 속해 있는지 강조할 때 사용된다. 예를 들어서 `a` 객체는 `Class` 클래스의 인스턴스다. 라고 표현한다.

## 기본형과 참조형

- 자바의 데이터 타입을 가장 크게보면 기본형과 참조형 두 개로 나뉜다.
- 기본형을 제외한 나머지 변수는 모두 참조형이다.
- 기본형 변수는 값을 직접 저장하지만, 참조형 변수는 참조(메모리 주소)를 저장한다.
- 기본형 변수는 산술 연산을 수행할 수 있지만, 참조형 변수는 산술 연산을 수행할 수 없다.
- 기본형 변수는 `null`을 할당할 수 없지만, 참조형 변수는 `null`을 할당할 수 있다.
- 대원칙: 자바는 항상 변수의 값을 복사해서 대입한다.
- 기본형, 참조형 모두 항상 변수에 있는 값을 복사해서 대입한다. 기본형이면 변수에 들어 있는 실제 값을 복사해서 대입하고 참조형이면 변수에 들어 있는 참조값을 복사해서 대입한다.
- 아무도 참조하지 않는 인스턴스는 GC(Garbage Collection)의 대상이 되어 자동으로 인스턴스를 메모리에서 제거한다.

## 객체 지향 프로그래밍

- 객체 지향 프로그래밍 객체들의 상호작용을 중심으로 프로그래밍 하는 방식이다.
- 세상 모든 사물을 단순하게 추상화해보면 속성(데이터)와 기능 2가지로 설명할 수 있다. 하지만 실제 세계는 매우 복잡하기 때문에 객체가 항상 1:1로 매칭되는 것은 아니다.

## 생성자

- 생성자는 객체 생성 직후 객체를 초기화 하기 위한 특별한 메서드
- 멤버 변수에 값을 할당할 때 this를 생략할 수 있다. 이 경우 가까운 지역 변수를 찾고, 없다면 멤버 변수를 찾는 순서로 작동 된다.
- 생성자 메서드는 클래스 이름과 같아야 한다.
- 생성자는 반환 타입이 없으므로 비워두어야 한다.
- 매개변수가 없는 생성자를 기본 생성자라고 한다.
- 대원칙: 인스턴스 생성시 생성자는 반드시 호출되어야 한다.
- 클래스에 개발자가 정의한 생성자가 하나도 없으면 컴파일러는 자동으로 매개변수가 없고, 작동하는 코드가 없는(메서드의 바디만 존재하는) 기본 생성자를 생성한다.
- 생성자가 하나라도 있으면, 기본 생성자가 제공되지 않는다.

## 패키지

- 패키지 이름과 위치는 폴더 위치와 같아야 한다.
- 패키지 이름은 모두 소문자를 사용한다.

## 접근 제어자

- private: 모든 외부 호출을 막는다.
- default(package-private): 같은 패키지 안에서 호출은 허용한다. 접근 제어자를 명시하지 않는 경우에 이 기본 접근 제어자가 적용 된다.
- protected: 같은 패키지안에서 호출은 허용한다. 패키지가 달라도 상속 관계의 호출은 허용한다.
- public: 모든 외부 호출을 허용한다.
- 접근 제어자는 필드와 메서드, 생성자에 사용된다.
- 클래스 레벨에서의 접근 제어자는 `public`, `default`만 사용할 수 있다.
- 하나의 자바 파일에 `public` 클래스는 하나만 등장할 수 있다.
- 하나의 자바 파일에 `default` 클래스는 무한정 만들 수 있다.
- [[Resources/Programming/Java/기본/캡슐화|캡슐화]]에 접근 제어자가 필요하다.

## 자바 메모리 구조와 static

- 자바 메모리 구조는 메서드 영역, 스택 영역, 힙 영역으로 나뉜다.
- 메서드 영역: 클래스 정보를 보관한다. 틀을 보관하는 것이다.
- 스택 영역: 실제 프로그램이 실행되는 영역이다. 메서드를 실행할 때 마다 하나씩 쌓인다.
- 힙 영역: 객체(인스턴스)가 생성되는 영역이다.
- 특정 클래스로 100개의 인스턴스를 생성하면 인스턴스는 힙 영역에 100개가 생성되고 각각의 인스턴스는 독립적으로 내부의 변수를 가진다.
- 하지만 메서드는 공통된 코드를 공유한다. 따라서 객체가 생성될 때 인스턴스 변수에는 메모리가 할당되지만 메서드에 대한 새로운 메모리 할당은 없다. 메서드는 메서드 영역에서 공통으로 관리하고 실행된다.
- `인스턴스 메서드`: `static`이 붙지 않은 멤버 메서드
- `클래스 메서드`: `static`이 붙은 멤버 메서드
- `static` 을 사용한 정적 변수는 메서드 영역에 생성되어 공통으로 관리된다.
- `static` 을 사용한 정적 메서드는 클래스 내부의 기능을 사용할 때 마찬가지로 `static`이 사용된 정적 변수나 정적 메서드만 사용할 수 있다.
- `static`을 사용한 정적 메서드는 접근 제어자만 허락한다면 클래스를 통해 모든 곳에서 접근할 수 있다.
- 특정 인스턴스의 기능을 사용하려면 참조값을 알아야 하는데 정적 메서드는 참조값 없이 호출한다. 따라서 정적 메서드 내부에서 인스턴스 변수나 인스턴스 메서드를 사용할 수 없다.

## final

- `final` 키워드는 더는 값을 변경할 수 없다는 의미를 지닌다.
- `final` 키워드는 호출 시점에 따라 작동 방식이 달라진다.
- `final` 키워드를 지역 변수에 설정할 경우, 값을 최초 한번만 초기화 할 수 있다.
- 매개변수에 `final`이 붙으면 메서드 내부에서 매개변수의 값을 변경할 수 없다.
- `상수(Constant):` `static`과 `final`이 동시에 사용됐을 때를 상수라고 한다. (공통적으로 사용하며, 절대 변하지 않는 값)
- `final`을 기본형 변수에 사용하면 값을 변경할 수 없다.
- `final`을 참조형 변수에 사용하면 참조값을 변경할 수 없다. 즉 참조값에 접근해서 객체를 변경하는 것은 가능하다.

## 상속

- `final` 키워드가 클래스에 사용되면, 상속 할 수 없다.
- `final` 키워드가 클래스 멤버 메서드에 사용되면, 상속 했을때 오버라이딩 할 수 없다.
- 상속 관계의 객체를 생성하면, 그 내부에는 호출자를 기준으로 모든 부모와 호출자 본인이 모두 생성된다.
- 호출자와 호출자 상위 모든 부모들의 생성자가 호출된다.
- 상속 관계의 객체를 호출할 때, 대상 타입을 정해야 한다. 이때 호출자의 타입을 통해 상위의 부모 중 일치하는 대상 타입을 찾는다.

## 다형성1

- 다형성은 한 객체가 여러 타입의 객체로 취급될 수 있는 능력을 뜻한다.
- 자바에서 부모 타입은 자신은 물론이고, 자신을 기준으로 모든 자식 타입을 참조할 수 있다.
- `다형적 참조`: 하위 자식 클래스가 상위 부모 클래스 타입으로 취급되는 것
- `다운 캐스팅`: 부모 타입에서 자식 타입으로 형변환
- `업 캐스팅`: 자식 타입에서 부모 타입으로 형변환 (생략 권장)
- 오버라이딩 된 메서드는 항상 호출 우선권을 가진다. 따라서 자식 타입이 부모 타입의 메서드를 오버라이딩 했고, 특정 메서드를 다형적 참조를 통해 공통적으로 사용할 때 내부적으로 부모 타입의 메서드가 아니라 오버라이딩 된 자식의 메서드가 우선 호출 된다.

## 다형성2

- 클래스는 단 하나의 부모만 가질 수 있다. (단일 상속)
- 다형성의 핵심은 `다형적 참조`와 `메서드 오버라이딩`이다. 여러 개로 분산되어 있는 타입을 `다형적 참조`로 합치고, 실제 호출 시점에 `메서드 오버라이딩`을 통해 인스턴스에 존재하는 오버라이딩 된 메서드를 사용하는 것이다.
- 추상 클래스는 추상적으로만 존재하는 클래스를 의미한다. 상속 목적으로만 사용하는, `다형적 참조`를 위한 클래스이다. 따라서 생성자 호출이 불가능하다.
- 추상 메서드는 해당 메서드의 추상적인 개념을 제공하는 메서드이다. 실체가 존재하지 않는다. 따라서 메서드 바디도 존재하지 않는다.
- 추상 메서드는 상속 받는 자식 클래스가 반드시 오버라이딩 해서 사용해야 한다.
- 추상 메서드를 명시하려면 반드시 추상 클래스여야 한다.
- `순수 추상 클래스`: 모든 메서드가 추상 메서드인 클래스
- `인터페이스`: 순수 추상 클래스를 더 편리하게 사용할 수 있는 기능
- 인터페이스는 `public`과 `abstract` 키워드를 생략할 수 있다.
- 인터페이스는 다중 구현(implements)이 가능하다.
- 인터페이스는 멤버 변수로 오직 상수만 가질 수 있다.
- 다중 상속은 같은 이름의 메서드가 존재하면 부모나 자식 중 어떤 타입의 메서드를 사용해야 할 지 애매한 문제가 발생한다. 이것을 다이아몬드 문제라 한다. 이 외에 자바는 클래스의 다중 상속을 허용 하지 않는다.
- 인터페이스는 추상 메서드로만 이루어져 있어, 구현을 가지지 않기 때문에 자식에서 정의한 함수를 호출하기만 하면 되므로 다중 상속이 가능하다.

> [!tip]
> 다중 상속에 관해 > [[인터페이스 다중 구현(다중 상속)]]

## 다형성과 설계

- 먼저 역할과 구현으로 분리하고 객체간의 상호작용을 중심으로 설계한다.

---

References: 김영한의 실전 자바 - 기본편

Links:
